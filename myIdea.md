# 引言
前端开发方面的工作尤其是面向用户端的，总是会遇到一些比较难或比较偏的效果和需求，这种时候我们一般会选择：  
- 直接在网上找别人已经写好的插件  
- 自己造轮子,自己开发插件  

如果在开发中总是想着用别人的东西，而不去自己尝试从一些简单的东西动手去做去实现，很容易让自己停滞不前
### 找插件的问题
- ui可能和设计的想法不一致，风格不搭，
- 插件与pm需求不符，如果非要用可能需要改很多东西
- 如果正好找到了一款和pm和设计都差不多一样的插件，还要学习用法，如果要用好，可能还要看源码，否则一旦需求有改动，可能就要皱眉了
- 一般比较好，比较靠谱的插件体积都很大，里面实现了很多的功能，可能项目组只用到了不到一半的功能
### 思考何时用别人的插件
- 需求功能复杂，比如html编辑器，比如可视化图表
- 工期紧，任务中，没时间自己开发
- 插件刚刚好符合，用的人多，体积不是很庞大
- 公司与自己的插件
### 自己开发插件
- 工期不紧，功能不是很复杂
- 自己一个人开发插件刚刚好，不需要别人
- 公司中经常用到的插件，可以考虑自己闲暇时封装
### 自己开发插件的好处
- 完全为项目定制，完全符合项目要求
- 后期需求改动，可以很容易更改或增加功能
- 对个人的技术和能力有个很好的提升
### 自己开发插件需要考虑的
- 对ui限制少，方便别人用的时候可以改变样式
- 插件可配置和默认参数设置值
- 在js全局环境下提供一个唯一的实例如JQuery.js的$，Vue.js的的Vue,可以防止内部的变量会污染全局作用域下的变量
- 暴露出必要的api方法，方便别人调用

- - -

### 最常见的插件开发方法
```
(function(global,factory){
    typeof exports ==='object' && typeof module !=='undefined' ? module.exports = factory() :
    typeof define ==='function' && define.amd ? define(factory) :
    (global.Name= factory());
})(this,function(){

//在此写逻辑

})
```
> * `typeof exports = == ‘object’ && typeof module != = ‘undefined’`这是判断条件exprots和module是CommondJS模块标准中下的对象，如果对象存在，那么说明引入环境是Node.js或者其他CommndJS环境，那么直接通过module.exports直接引入逻辑代码。否则是其他模式。  
> * `typeof define === ‘function’ && define.amd`，而这个条件是判断模块引入是以amd标准引入的，像require.js 就是以这种规范引入模块的，以define(factory)方法引入逻辑代码。除去这两种剩下的就是不存在模块引入而是直接调用的情况了，也就是在`全局对象中抛出逻辑代码`。

# 正文
## 分享的插件： 移动端下拉刷新，上拉加载

**需求**
* 参数:
    * container，插件作用的dom
    * 可配置是需要`上拉加载`、`下拉刷新`，还是`两者都需要`
    * 上拉加载配置：  
        * 距离页面底部多远时开始出发加载
        * 正在加载时显示的文字
        * 没有更多数据的时候显示的文字
        * 出发加载更多时的callback
    * 下拉刷新配置:  
        * 向下拖动页面多长然后松开手指可以出发刷新
        * 向下拖页面时显示的文字
        * 可以出发刷新时显示的文字
        * 刷新完成时显示的文字
        * 出发刷新时的callback
        * 阻尼
* 实现功能
    * 上拉加载更多：
        * 方法初始化后，如果dom内容没有满dom高度，则自动出发`加载callback`，并显示`正在加载时显示的文字`
        * dom内容滚动时，当达到规定距离时，自动触发`加载callback`，并显示`正在加载时显示的文字`
        * 当页面正在加载更多的时候，来回滚动页面，不可多次出发`加载callback`
    * 下拉刷新:  
        * 页面向下拉到规定距离时松手出发`刷新callback`，并显示正在`刷新完成时显示的文字`,否则页面回到最顶部
        * 当页面正在刷新时，禁用页面再次向下拉动
        * 下拉时增加阻尼，防止页面过度向下拉
* 暴露必要的方法:   

* 效果实现与优化思考：
    * 根据参数设置自动在页面插入上拉或下拉所需要的html
    * 在用`插件`（iscroll\AlloyTouch）来实现滚动还是用`原生`滚动上，选择了原生
    * 上拉加载更多：
        * 当页面`scrollTop>0`是，实时监控dom的`scroll`事件，并计算是否到达指定位置
    * 下拉刷新: 
        * 在用`transform`还是用`一个空标签更改高度`的方式来改变dom下拉的效果时选择了前者
        * 当页面`scrollTop<=0`是，实时监控dom的`touchmove`相对于`touchstart`移动的距离,并让dom的`transform:translate3d`和移动的距离保持同步
